Structs should not be defined unless a single value consumes 16 bytes or less of storage, is immutable, and is infrequently boxed.

Since value types require a memory copy, they generally should be defined to consume a small amount of memory (typically 16 bytes or less).

Values of value types are often short-lived; in many situations, a value is needed only for a portion of an expression or for the activation of a method. In these cases, variables and temporary values of value types can often be stored in the temporary storage pool, called the stack. (This term is actually a misnomer: There is no requirement that the temporary pool allocates its storage off the stack. In fact, as an implementation detail, it frequently chooses to allocate storage out of available registers instead.)

# Reference Equality versus Value Equality
Two references are identical (reference equal) if both refer to the same instance of an object. On the other hand, objects that have the same values are value equal. And, to support value equal, a type needs to implement value-based equality. Two objects that are reference equal obviously are also value equal—the comparison is between two references to the same object. However, two objects can be of equal value if the (relevant) data between them is also equal. Only reference types can be reference equal, thereby supporting the concept of identity—the two references refer to the same instance. In contrast, value types can never be reference equal. Each value type is stored in a different location (reference) in memory, and even the simple act of passing value types to method for comparison will create additional copies of the value types.

Calling `ReferenceEquals()` on value types will always return false.

While value types can never be reference equal, a reference type can support value equals. `object` includes a static method called `ReferenceEquals()` that checks whether the two arguments are identical—reference equal. In addition, `object` defines a virtual `Equals()` method that, by default, invokes `ReferenceEquals()` for reference types. However, this `Equals()` method can be customized (on both reference types and value types) so that they implement value equality rather than reference.

# Structs
starting with C# 9.0, a lot of the complexity associated with creating a struct is eliminated with a new contextual keyword— #record —that triggers the compiler into generating much of the important and complex code related to value type behavior.

```c#
// Use the record struct construct to declare a value type

public readonly record struct Angle(

    int Degrees, int Minutes, int Seconds, string? Name = null);
```

While optional,1 the parameters in the record declaration are called positional parameters, and they provide the key definition of the type. As a result, this simple code construct called a record struct has all the requisites of what you need to build a value type including value type declaration, data storage with properties, immutability, constructor initialization, deconstruction, equivalence behavior and even `ToString()` diagnostic capabilities.


```C#
public class Program

{

    public static void Main()

    {

        (int degrees, int minutes, int seconds) = (

            90, 0, 0);

        // The constructor is generated using positional parameters

        Angle angle = new(degrees, minutes, seconds);

        // Records include a ToString() implementation

        // that returns:

        //   "Angle { Degrees = 90, Minutes = 0, Seconds = 0, Name =  }"

        Console.WriteLine(angle.ToString());

        // Records have a deconstructor using the 

        // positional parameters.

        if (angle is (int, int, int, string) angleData)

        {

            Trace.Assert(angle.Degrees == angleData.Degrees);

            Trace.Assert(angle.Minutes == angleData.Minutes);

            Trace.Assert(angle.Seconds == angleData.Seconds);

        }

        Angle copy = new(degrees, minutes, seconds);

        // Records provide a custom equality operator.

        Trace.Assert(angle == copy);

        // The with operator is the equivalent of

        // Angle copy = new(degrees, minutes, seconds);

        copy = angle with { };

        Trace.Assert(angle == copy);

        // The with operator has object initializer type

        // syntax for instantiating a modified copy.

        Angle modifiedCopy = angle with { Degrees = 180 };

        Trace.Assert(angle != modifiedCopy);

    }

}
```

## Record Struct Code Generation
All the functionality of a record struct is generated by the C# compiler at compile time.
Note that in C# 9.0, the record keyword without the struct keyword was all that the compiler allowed. However, in C# 10 (with the introduction of records for structs), the explicit declaration of record struct was added. For clarity, I recommend using record struct always, rather than the abbreviated record-only syntax.

All value types are implicitly sealed (you can’t derive from them). In addition, all non-enum value types derive from `System.ValueType`. Consequently, the inheritance chain for structs is always from object to `System.ValueType` to the custom struct.

# Record Classes
Starting in C# 9, support was added for `record` classes.

The key, and perhaps the only reason to define a record class, is if the type needs to have value equality behavior. In fact, whenever a custom type needs to implement value equality (always the case for a value type), the record construct should be used if possible. An example of when it might not be possible is working with a C# version prior to C# 9 (for a reference type) or C# 10.0 (for a value type).

Another time when the record construct cannot be used on a class is when the base class is not a record. A record class can inherit only from another record class, while a standard class can inherit only from another standard class. The inheritance chain cannot mix and match between standard classes and records.

There are several expected differences in the records struct versus record class–generated code.
First, several members are decorated with virtual modifiers. Virtual was never used in the record struct since all structs are sealed, making virtual nonsensical in the record struct case.

Second, a record class needs to account for the possibility of a null value.

## Using `new` with Value Types

invoking the new operator with a value type causes the runtime to create a new instance of the object on the temporary storage pool, initialize all of its fields to their default values, and call the constructor (passing the temporary storage location as a ref variable through this), resulting in the value being stored in the temporary storage location, which can then be copied to its final destination.

Unlike classes, structs do not support finalizers. Structs are copied by value; they do not have referential identity, as reference types do. Therefore, it is hard to know when it would be safe to execute the finalizer and free an unmanaged resource owned by the struct. The garbage collector knows when there are no “live” references to an instance of reference type and can choose to run the finalizer for an instance of reference type at any time after there are no more live references. Nevertheless, no part of the runtime tracks how many copies of a given value type exist at any moment.

# Overriding `object` Members
## Overriding `ToString()`
By default, calling `ToString()` on any object will return the fully qualified name of the object type.
Write methods such as `System.Console.WriteLine()` and `System.Diagnostics.Trace.Write()` call an object’s `ToString()` method, so overriding the method often outputs more meaningful information than the default implementation.

Overriding `ToString()` requires nothing more than declaring the `ToString()` method as override and returning a string. For example:

```C#
public override string ToString()

{

     string prefix =

     string.IsNullOrWhiteSpace(Name)?string.Empty : Name+": ";

     return $"{prefix}{Degrees}° {Minutes}' {Seconds}\"";

}
```

Regardless, do not return an empty string or `null`, as the lack of output will be very confusing. `ToString()` is useful for debugging from within a developer IDE or writing to a log file. The lack of localization and other advanced formatting features makes this approach less suitable for general end-user text display. For this reason, you should keep the strings relatively short (one screen width) so that they are not truncated off the end of the screen.

## [Implementing Value Equality](https://essentialcsharp.com/implementing-value-equality#implementing-value-equality)

# Boxing
Boxing is when a value type is converted to a reference type.
Unboxing is when a reference type is converted to a value type.
Every boxing operation involves both an allocation and a copy; every unboxing operation involves a type check and a copy. Doing the equivalent work using the unboxed type would eliminate the allocation and type check

# Enum
An enum is a value type that the developer can declare. The key characteristic of an enum is that it declares, at compile time, a set of possible constant values that can be referred to by name, thereby making the code easier to read.
You use an enum value by prefixing it with the enum’s name.
By convention, the enum name itself should be singular (unless the enum values are bit flags, as discussed shortly).
Enum values are actually implemented as nothing more than integer constants. By default, the first enum value is given the value 0, and each subsequent entry increases by 1. Alternatively, you can assign explicit values to enum members.
An enum always has an underlying type, which may be any integral type other than char. In fact, the enum type’s performance is identical to that of the underlying type. By default, the underlying value type is int, but you can specify a different type using inheritance type syntax.

```C#
enum ConnectionState : short

{

    Disconnected,

    Connecting = 10,

    Connected,

    Joined = Connected,

    Disconnecting

}
```

For consistency, the syntax for enums emulates the syntax of inheritance, but it doesn’t actually create an inheritance relationship. The base class for all enums is `System.Enum`, which in turn is derived from `System.ValueType`. Furthermore, these enums are sealed; you can’t derive from an existing enum type to add more members.
he enum values provide names for the known values while still allowing unknown values to be assigned at runtime. The burden is that developers must code defensively for the possibility of unnamed values

## Type Compatibility between Enums
C# also does not support a direct cast between arrays of two different enums. However, the CLR does, provided that both enums share the same underlying type. To work around this restriction of C#, the trick is to cast first to `System.Array`.

```C#
ConnectionState1[] states = (ConnectionState1[])(Array)new ConnectionState2[42];
```

## Converting between Enums and Strings
One of the conveniences associated with enums is that the `ToString()` method, which is called by methods such as `System.Console.WriteLine()`, writes out the enum value identifier, not value itself.

